---
title: "Uke 38"
format: html
editor: visual
---

```{r}
library(tidyverse)
library()
library(readxl)
library(PxWebApiData)
library(writexl)
library(readxl)
library(reshape2)
```

## Uke 38

#Dag 18.09.2025

## Three Variables

-   Kan gjøre det via et 3-d plot (ikke så sykt bruktbart)

Har man en kontirnuerlig variabel, kan man bruke størrelse, fargemetning (hvor stor fargemetting en har), den tredje er å bruke farger. Men siden vi har en kontinuerlig variabel kan vi ikke ha forksjellige farger, men heller fra lysere til mørkere farge. Bruker man størrelse går de fra mindre til større eller motsatt (alt er mulig så lenge du manipulere koden). Dette gjør ggplot hvis du har en kontinuerlig variabel.

Ved bruk av geom_text() kan man gi navn til de ulike delene, f.eks, bil navn til de ulike variablene, se side 25 av slidse til læraren.

HOSTHOST: Læraren liker bedre størrelser enn farge, bare et sånt lite tips.

-   En annen startegi er Facets, at de blir delt opp i grupper.

Tatt en variabel og delt den i tre ulike grupper. Dette kalles for "faktor/kategori variabel". Dette består av et sett av dummy variabler. Heldigvis så blir det autmatisert i R-studio hvis du gjør det til en faktor, mens i et annet program (Excel) måtte man gjort det manuelt (flere dummy variabler).

Facet_wrap (\~) "fekk ikke sjangs til å følge med eller skrive om dette av læraren"

Ved å legge til en mapping = aes(color = det du skal dele inn i vekt, typ det læraren skreiv cut_number(wt, n = 3)),

fekk ikke til å gjør det under, men skal prøve senere

```{r}
ggplot(
  data = mtcars, 
  mapping = aes(
    x = hp, 
    y = 1609.347/(2*qsec^2)
    )
  ) +
  facet_wrap(~cut_number(wt, n =3)) +
  geom_point(
    aes(colour = cut_number(
      wt, 
      n = 3)
      )
    ) +
  geom_smooth(
    method = "lm", 
    se = FALSE
    )
```

Det går ant å gjør det via ggplot() delen, der du setter inn

Man må legge inn et geom for å legge til alle punktene i en svak farge for at det skal være litt uklart men mulig å se hvor de ulike plotene er. Her ser vi delen der det står Labes, som gjør det til de ulike tonene. Dette hjelper leseren å forstå litt mer.

Der du ser Geom_point ser du at fargen er byttet til svak grå.

```{r}
#new dataframe to use for the grey points
hp_acc <- data.frame(
  hp = mtcars$hp, 
  acc = 1609.347/(2*mtcars$qsec^2)
  )

ggplot(
  data = mtcars, 
  mapping = aes(
    x = hp,
    y = 1609.347/(2*qsec^2))
  ) +
  geom_point(
    data = hp_acc, 
    mapping = aes(x = hp, y = acc), 
    colour = "grey80"
    ) +
  facet_wrap(
    ~cut_number(
      wt, 
      n =3 , 
      labels = c("Light", "Medium", "Heavy")
      )
    ) +
  geom_point(
    mapping = aes(colour = cut_number(
      wt, 
      n = 3, 
      labels = c("Light", "Medium", "Heavy")
      )
      ),
    show.legend = FALSE
    ) +
  geom_smooth(
    method = "lm", 
    se = FALSE
    ) +
  labs(
    y = "Mean acceleration (m/s^2)", 
    colour = "Weight"
    )
```

Stack Overflow er en nettside der du kan finne svar på typiske R problematiske spørsmål. Veldig bra og vi kommer til å bruke det framøve når læraren ikke svarer på det.

## To Facet Variabler

Vi kan og ha Facet for to variabler, ikke bare en.

Da legger vi rekke variabelen før

Det som er endret er istedenfor facet_wrap, har han brukt facet_grid.

Det som kommer før krøllen (\~) er det som kommer på rekkene og det osm kommer etter er det som kommer på kollonene. Da snakker eg om denne koden:

factor(cyl)\~cut_number( wt, n = 3 , labels = c("Light", "Medium", "Heavy"))

```{r}
ggplot(
  data = mtcars, 
  mapping = aes(x = hp, y = 1609.347/(2*qsec^2))
  ) +
  
  geom_point(
    data = hp_acc, 
    mapping = aes(x = hp, y = acc), 
    colour = "grey80"
    ) +
    facet_grid(
    factor(cyl)~cut_number(
      wt, 
      n = 3 , 
      labels = c("Light", "Medium", "Heavy"))
    ) +
  
  geom_point(
    mapping = aes(
      colour = cut_number(
        wt, 
        n = 3, 
        labels = c("Light", "Medium", "Heavy")
        )
      ),
    show.legend = FALSE
    ) +
  
  geom_smooth(
    method = "lm", 
    se = FALSE
    ) +
  
  labs(
    y = "Mean acceleration", 
    colour = "Weight"
    )
```

ggplot er det som ligger i tidyverse.

Noe som heter Latticce som er eldre en ggplott, men eldre enn det klasiske plot programet. Vises på side 32 i slidsene

## Grei info: 

Grei bok å ha på nett (gratis tilgang) for diagrammer og dvs: <https://ggplot2-book.org/individual-geoms.html>

Denne er også grei: <https://socviz.co/>

Denen viser veldig konkret og ulike måter å endre til hvordan det skal se ut: [https://clauswilke.com/dataviz/](#0)

## Ny slide. Transforming Data (chap. 5 r4ds).

Forklare hvordan vi manipulerer databilder. Læraren anbefaler oss å prøve dette i et quarto document sånn at vi har forklaringer og steg for oss selv.

Hva går dette utpå:

Det er en samling av verb som hjelper oss å manipulerer det vi skal finne ut av.

filter() hjelper oss å bare ta ut det vi selv vil ha istedenfor å ha 1000 forskjellige datasett.

arrange() handler mer om utseende, den sorterer med hensyn på en eller flere variabler. Endrer ikke på selve datasette men i hva rekkefølge de kommer i

select() endrer på variablene. Den tar altså ut hva slags vi kan plukke ut som vi er interesert i

mutate() bruker vi til å lage nye variabler (renames osv). Denne kommer vi til å bruke mye av

transmute() beholder de nye variablene, ikke så viktig egentlig.

rename() endrer navne på variabelen/ene.

summarise() regner vi ut grupper, mens groupe_by() hjelper oss til å gruppere variabelen, typ (max, min, mean, media, sd etc).

Vi skal burke og lære oss om "pipe". Pipe stammer fra Unix Shell programmering. Var ikke en del av R før, noen ville legge til pipes i R siden

Her blir det trukket 10 randome antall normalfordelte tall, som går ut gjennom "mean", så ut til en ny som heter round, som tar det utifra 3 desimaltall (digits). Dette er hva vi kaller for function to function to function, kan vær litt slitende og vanskelig å skjønne hva som skjer og hvor du er i en kode.

```{r}
set.seed(1234)
res_mean_rnorm_3dig <- paste("Result:", round(mean(rnorm(n = 10, mean = 0, sd = 1)), digits = 3), sep = "")
res_mean_rnorm_3dig
```

Temporary variables

Som kan vær litt slitende siden da kommer det opp i temp 1-3 osv

```{r}
set.seed(1234)
tmp <- rnorm(n = 10, mean = 0, sd = 1)
tmp1 <- mean(tmp)
tmp2 <- round(tmp1, digits = 3)
paste("Result:", tmp2, sep = "")
```

```{r}
# ^t, object names that start with 't' 
ls(pattern = "^t")
```

pipe karakter = %\>%

Mens med Pipes kan vi først generere dataene, så teller vi de inn ved en større tegn i 2 % tegn. Da heller vi dataen inn i en pipe, som går videre til funkjsonen mean(), som regner gjennomsnitte (som gir oss et tall av de 10 normalfordelte tallene). Den vil dermed gå videre ned til round() som går fra 16 til 3 desimaltaller, så ned til siste som er paste() som limer tallene med rekst.

Det eneste som kna vippe oss av, av og til, er at vi må huske ka som kommer inn i røret og hva som kommer ut.

Jøvla forvirende med tekst, men bare forestil deg et rør (sylinder) der den øverste er mean() så round() så paste()

viktig komando i econometri.

ln funksjon. Dataene til regresjonen er andre argument, mens første er selve funksjonen. Eks Y vil ikke vises siden den allerede er i dataen, mens X og Z er det vi ser visuelt i regresjonsmodellen.

Sån som her: paste("Result:", .)

Her vises punktumet på slutten at arggumentet skal komme inn som nummer 2 og ikke inn som nummer 1.

```{r}
set.seed(1234)
res_mean_rnorm_3dig_string <- 
  rnorm(n = 10, mean = 0, sd = 1) %>%
  mean() %>%
  round(digits = 3) %>% 
  # The dot '.' is to show where the content of the pipe should be put
  paste("Result:", .)
res_mean_rnorm_3dig_string
```

Husk å last ned: viewpipesteps for å vise svarene for hvert steg.

rnorm(n = 10, mean = 0, sd = 1) %\>%

mean() %\>%

```{r}
set.seed(1234)
res_mean_rnorm_3dig_string <- 
  rnorm(n = 10, mean = 0, sd = 1) %>%
  mean() %>%
  round(digits = 3) %>% 
  # The dot '.' is to show where the content of the pipe should be put
  paste("Result:", .)
res_mean_rnorm_3dig_string
```
