---
title: "Uke 38"
format: html
editor: visual
---

```{r}
library(tidyverse)
library()
library(readxl)
library(PxWebApiData)
library(writexl)
library(readxl)
library(reshape2)
```

## Uke 38

#Dag 18.09.2025

## Three Variables

-   Kan gjøre det via et 3-d plot (ikke så sykt bruktbart)

Har man en kontirnuerlig variabel, kan man bruke størrelse, fargemetning (hvor stor fargemetting en har), den tredje er å bruke farger.
Men siden vi har en kontinuerlig variabel kan vi ikke ha forksjellige farger, men heller fra lysere til mørkere farge.
Bruker man størrelse går de fra mindre til større eller motsatt (alt er mulig så lenge du manipulere koden).
Dette gjør ggplot hvis du har en kontinuerlig variabel.

Ved bruk av geom_text() kan man gi navn til de ulike delene, f.eks, bil navn til de ulike variablene, se side 25 av slidse til læraren.

HOSTHOST: Læraren liker bedre størrelser enn farge, bare et sånt lite tips.

-   En annen startegi er Facets, at de blir delt opp i grupper.

Tatt en variabel og delt den i tre ulike grupper.
Dette kalles for "faktor/kategori variabel".
Dette består av et sett av dummy variabler.
Heldigvis så blir det autmatisert i R-studio hvis du gjør det til en faktor, mens i et annet program (Excel) måtte man gjort det manuelt (flere dummy variabler).

Facet_wrap (\~) "fekk ikke sjangs til å følge med eller skrive om dette av læraren"

Ved å legge til en mapping = aes(color = det du skal dele inn i vekt, typ det læraren skreiv cut_number(wt, n = 3)),

fekk ikke til å gjør det under, men skal prøve senere

```{r}
ggplot(
  data = mtcars, 
  mapping = aes(
    x = hp, 
    y = 1609.347/(2*qsec^2)
    )
  ) +
  facet_wrap(~cut_number(wt, n =3)) +
  geom_point(
    aes(colour = cut_number(
      wt, 
      n = 3)
      )
    ) +
  geom_smooth(
    method = "lm", 
    se = FALSE
    )
```

Det går ant å gjør det via ggplot() delen, der du setter inn

Man må legge inn et geom for å legge til alle punktene i en svak farge for at det skal være litt uklart men mulig å se hvor de ulike plotene er.
Her ser vi delen der det står Labes, som gjør det til de ulike tonene.
Dette hjelper leseren å forstå litt mer.

Der du ser Geom_point ser du at fargen er byttet til svak grå.

```{r}
#new dataframe to use for the grey points
hp_acc <- data.frame(
  hp = mtcars$hp, 
  acc = 1609.347/(2*mtcars$qsec^2)
  )

ggplot(
  data = mtcars, 
  mapping = aes(
    x = hp,
    y = 1609.347/(2*qsec^2))
  ) +
  geom_point(
    data = hp_acc, 
    mapping = aes(x = hp, y = acc), 
    colour = "grey80"
    ) +
  facet_wrap(
    ~cut_number(
      wt, 
      n =3 , 
      labels = c("Light", "Medium", "Heavy")
      )
    ) +
  geom_point(
    mapping = aes(colour = cut_number(
      wt, 
      n = 3, 
      labels = c("Light", "Medium", "Heavy")
      )
      ),
    show.legend = FALSE
    ) +
  geom_smooth(
    method = "lm", 
    se = FALSE
    ) +
  labs(
    y = "Mean acceleration (m/s^2)", 
    colour = "Weight"
    )
```

Stack Overflow er en nettside der du kan finne svar på typiske R problematiske spørsmål.
Veldig bra og vi kommer til å bruke det framøve når læraren ikke svarer på det.

## To Facet Variabler

Vi kan og ha Facet for to variabler, ikke bare en.

Da legger vi rekke variabelen før

Det som er endret er istedenfor facet_wrap, har han brukt facet_grid.

Det som kommer før krøllen (\~) er det som kommer på rekkene og det osm kommer etter er det som kommer på kollonene.
Da snakker eg om denne koden:

factor(cyl)\~cut_number( wt, n = 3 , labels = c("Light", "Medium", "Heavy"))

```{r}
ggplot(
  data = mtcars, 
  mapping = aes(x = hp, y = 1609.347/(2*qsec^2))
  ) +
  
  geom_point(
    data = hp_acc, 
    mapping = aes(x = hp, y = acc), 
    colour = "grey80"
    ) +
    facet_grid(
    factor(cyl)~cut_number(
      wt, 
      n = 3 , 
      labels = c("Light", "Medium", "Heavy"))
    ) +
  
  geom_point(
    mapping = aes(
      colour = cut_number(
        wt, 
        n = 3, 
        labels = c("Light", "Medium", "Heavy")
        )
      ),
    show.legend = FALSE
    ) +
  
  geom_smooth(
    method = "lm", 
    se = FALSE
    ) +
  
  labs(
    y = "Mean acceleration", 
    colour = "Weight"
    )
```

ggplot er det som ligger i tidyverse.

Noe som heter Latticce som er eldre en ggplott, men eldre enn det klasiske plot programet.
Vises på side 32 i slidsene

## Grei info:

Grei bok å ha på nett (gratis tilgang) for diagrammer og dvs: <https://ggplot2-book.org/individual-geoms.html>

Denne er også grei: <https://socviz.co/>

Denen viser veldig konkret og ulike måter å endre til hvordan det skal se ut: [https://clauswilke.com/dataviz/](#0)

## Ny slide. Transforming Data (chap. 5 r4ds).

Forklare hvordan vi manipulerer databilder.
Læraren anbefaler oss å prøve dette i et quarto document sånn at vi har forklaringer og steg for oss selv.

Hva går dette utpå:

Det er en samling av verb som hjelper oss å manipulerer det vi skal finne ut av.

**filter()** hjelper oss å bare ta ut det vi selv vil ha istedenfor å ha 1000 forskjellige datasett.

**arrange()** handler mer om utseende, den sorterer med hensyn på en eller flere variabler.
Endrer ikke på selve datasette men i hva rekkefølge de kommer i

**select()** endrer på variablene.
Den tar altså ut hva slags vi kan plukke ut som vi er interesert i

**mutate()** bruker vi til å lage nye variabler (renames osv).
Denne kommer vi til å bruke mye av

*transmute()* beholder de nye variablene, ikke så viktig egentlig.

*rename()* endrer navne på variabelen/ene.

**summarise()** regner vi ut grupper, mens groupe_by() hjelper oss til å gruppere variabelen, typ (max, min, mean, media, sd etc).

## Function to Function to Function

Her blir det trukket 10 randome antall normalfordelte tall, som går ut gjennom "mean", så ut til en ny som heter round, som tar det utifra 3 desimaltall (digits).
Dette er hva vi kaller for function to function to function, kan vær litt slitende og vanskelig å skjønne hva som skjer og hvor du er i en kode.

```{r}
set.seed(1234)
res_mean_rnorm_3dig <- paste("Result:", round(mean(rnorm(n = 10, mean = 0, sd = 1)), digits = 3), sep = "")
res_mean_rnorm_3dig
```

## Temporary variables

## Som kan vær litt slitende siden da kommer det opp i temp 1-3 osv

```{r}
set.seed(1234)
tmp <- rnorm(n = 10, mean = 0, sd = 1)
tmp1 <- mean(tmp)
tmp2 <- round(tmp1, digits = 3)
paste("Result:", tmp2, sep = "")
```

```{r}
# ^t, object names that start with 't' 
ls(pattern = "^t")
```

## Pipe

Vi skal burke og lære oss om "pipe".
Pipe stammer fra Unix Shell programmering.
Var ikke en del av R før, noen ville legge til pipes i R siden.

pipe symbol/karakter = %\>%

Mens med Pipes kan vi først generere dataene, så teller vi de inn ved en større tegn i 2 % tegn.
Da heller vi dataen inn i en pipe, som går videre til funkjsonen mean(), som regner gjennomsnitte (som gir oss et tall av de 10 normalfordelte tallene).
Den vil dermed gå videre ned til round() som går fra 16 til 3 desimaltaller, så ned til siste som er paste() som limer tallene med rekst.

Det eneste som kna vippe oss av, av og til, er at vi må huske ka som kommer inn i røret og hva som kommer ut.

Jævla forvirende med tekst, men bare forestil deg et rør (sylinder) der den øverste er mean() så round() så paste()

Viktig komando i econometri.

ln funksjon.
Dataene til regresjonen er andre argument, mens første er selve funksjonen.
Eks Y vil ikke vises siden den allerede er i dataen, mens X og Z er det vi ser visuelt i regresjonsmodellen.

Sånn som her: paste("Result:", .)

Her vises punktumet på slutten at arggumentet skal komme inn som nummer 2 og ikke inn som nummer 1.

```{r}
set.seed(1234)
res_mean_rnorm_3dig_string <- 
  rnorm(n = 10, mean = 0, sd = 1) %>%
  mean() %>%
  round(digits = 3) %>% 
  # The dot '.' is to show where the content of the pipe should be put
  paste("Result:", .)
res_mean_rnorm_3dig_string
```

Husk å last ned: viewpipesteps for å vise svarene for hvert steg.

rnorm(n = 10, mean = 0, sd = 1) %\>%

mean() %\>%

```{r}
set.seed(1234)
res_mean_rnorm_3dig_string <- 
  rnorm(n = 10, mean = 0, sd = 1) %>%
  mean() %>%
  round(digits = 3) %>% 
  # The dot '.' is to show where the content of the pipe should be put
  paste("Result:", .)
res_mean_rnorm_3dig_string
```

Det som er greit med pipe er at det som går som output fra en funksjon går til en input for neste funksjon.
Alt om tidyverse skal være designa for å gå hand i hand med pipes metoden.

## nycflights13

Nå skal vi bruke nycflight13 å renke litt ut her og der.

```{r}
library(nycflights13)
```

```{r}
flights %>% as_tibble()
```

Her ser du at 336,776 = n (antall)

Ved bruk av ?f
lights i consol får vi opp på help til høyre hjørnet hva de ulike variablene betyr.
Vi ser at sched_de er når flyet gikk.
Den første ser vi gikk 5:15, og til høyre for den viser den at den er 2 min forsinket, osv.

## 10.09.2025

Nå begynner vi på New York Flights på de tre ulike flyplassene i New York

```{r}
library(tidyverse)
library(nycflights13)
```

```{r}
print(
  head(flights, n = 5),
  width = 70
  )
```

Første vi skal gjør er å bruke filterings kommandoen filter().
Her har vi gått utifra at month 1 er Januar.

```{r}
print(
  filter(flights, month == 1, day == 1),
  n = 5, 
  width = 70
)
```

Fant ut at hvis du går på tools, globale option, code, editing så markerer du use native pipe operator \|\>.
Da kan du trykke ctrl, shit og M, så får du opp dette symbolet \|\> som betyr: \|\> = %\>% (pipe).

```{r}
#| paged.print: False
   flights |> 
     filter(month == 1, day == 1) |> 
     print(n = 5)
```

```{r}
#| paged.print: False
  flights |> 
  filter(
  month == 1, 
  day %in% c(1, 15, 30)
  ) |> 
    tail(n = 7) |> 
  print(
    width = 60
  )
```

Tail er halen som viser oss at han skal hente ut de 7 siste.

```{r}
#| paged.print: False
  flights |> 
  filter(
  month == 1, 
  day %in% c(1, 15, 30)
  ) |> 
    arrange(desc(day))
```

Det som skjer på slutten her der vi tar arrange(desc(day)) er at den begynner på 30, så 15 så 1, altså den starter i motsatt ende.
Der det står 3 på dep_time er at den letter (flyr) 00:03 30.
Januar.
2013.

```{r}
#| paged.print: False
  flights |> 
  filter(
  month == 1, 
  day %in% c(1, 15, 30)
  ) |> 
    arrange(desc(day), desc(dep_time))
```

Ved å legge til desc(dep_time) vil den begynner fra seinest til tidligst.

```{r}
#| paged.print: False
  flights |> 
  filter(
  month == 1, 
  day %in% c(1, 15, 30)) |> 
 slice_sample(n = 10) |> 
    arrange(desc(day), desc(dep_time))
```

Dette er et tilfeldig utvalg av 10 verdier som vil være forksjelig for hver gang

```{r}
#| paged.print: False
  set.seed(1111)
  flights |> 
  filter(
  month == 1, 
  day %in% c(1, 15, 30)) |> 
 slice_sample(n = 10) |> 
    arrange(desc(day), desc(dep_time))
```

Ved å bruke set.seed() vil det gi oss det samme svaret om igjen utifra utvalget.
Du må bare endre n = et tall for å endre resultatet.

Operators /opperatorer hjelper oss med at når vi skal se om noe er likt.
Da skriver vi bare eks, 2 == 2 så får du opp TRUE eller FALSE, i dette tilfelle vil det være TRUE.

```{r}
2 == 2

```

-   For å se om to ting er lik hverandre kan vi bruke **near()**, i tilfelle ting er numerisk tilnærmet eller lik noe (at du får feil utslag (TRUE/FALSE) pågrunn av desimaltall.
    Husk å last ned tidyverse for at den skal funke.

-   ! (utroppstegn) kan og snu en verdi fra TRUE til FALSE, og motsatt.
    eks:

    ```{r}
    !(2L == 2L)
    ```

## Uke 39

For å finne flyene fra April og Septemeber ilag, er det mulig å enten skrive **nrow()** eller **count()**.
Begge gir samme svar

```{r}
#| paged.print: False
  flights %>%  
  filter(month %in% c(4, 9)) %>%
  nrow()
```

```{r}
#| paged.print: False
  flights %>%  
  filter(month %in% c(4, 9)) %>%
    count()
```

Hvis du bruker **Og** tegnet **(en vannrett linje)** så kan du finne det samme svaret, bare at du ser det litt enklere.

```{r}
#| paged.print: False
  flights %>%  
  filter(month == 4 | month == 9) %>%
    count()
```

-   Finn ut hvor mange fly det var fra april til september.

    Det vi må gjør er å grupere de i gruppe fra 4 til 9, derifra må vi grupere det til variabelen vi vil ha month(), så må vi summere antallene ved å kalle antall = n().
    Da gjør vi sånn at n bli definert som antall.

```{r}
#| paged.print: False
  flights |>  
  filter(month %in% 4:9) |> 
    group_by(month) |> 
    summarise(antall = n())
```

-   Hvor mange fly var det toalt i de to ulike månede utifra de to første dagene.

```{r}
#| paged.print: False
  flights |>  
    filter(day %in% c(1,2)) |> 
    group_by(month, origin) |> 
    summarise(antall = n())
```

-   Definer alle flyvininger som skjedde første i hver måned

```{r}
#| paged.print: False
  flights |>  
    filter(day %in% c(1)) |> 
    summarise(antall = n())
```

-   Gjør det samme men for hver flyplass

```{r}
#| paged.print: False
  flights |>  
    filter(day %in% c(1)) |> 
    group_by(origin) |> 
    summarise(antall = n())
```

Ved å ta inn koden prin(n = 60) vil du få ut for hver måned, hvis du trekker inn month og i group_by

```{r}
#| paged.print: False
  flights |>  
    filter(day %in% c(1)) |> 
    group_by(month, origin) |> 
    summarise(antall = n()) |> 
  print(n = 60)
```

-   hvor mange fly var det siste dag for hver måned for hver flyplass

```{r}
#| paged.print: False
  flights |>  
    group_by(month, origin) |> 
    filter(day == max(day)) |> 
    summarise(antall = n()) |> 
  print(n = 40)
```

For å sjekke om dette er rett er å velge ut noen av de typ Januar, og se om de har samma svar, siden siste dag i måneden varierer fra månede og månede og skuddår.
Siden vi valgte Januar så vet vi at den har 31 dager.

```{r}
#| paged.print: False
  flights |>  
    filter(month == 1 & day == 31) |> 
    group_by(origin) |> 
    summarise(antall = n())
```

-   Hvor mange fly var det i 2013 som hadde en forsinkelse større eller lik 15 minnutter, men mindre enn 30 min. arr_delay = forsinkelse

```{r}
#| paged.print: False
  flights |>  
    filter(arr_delay >= 15 & arr_delay < 30) |> 
    count()
```

Hvor mange fly var forsinket

```{r}
#| paged.print: False
flights |>  
    filter(arr_delay >= 15 & arr_delay < 30) |>
    count()
```

Hvor mange fly var forsinket i % (svaret er 8,11%)

```{r}
#| paged.print: False
 delays <- flights |>  
    filter(arr_delay >= 15 & arr_delay < 30) |>
    count() |> 
    pull()
    
 round(100 * delays/nrow(flights), 2)
```

Hvordan var dette på hver flyplass

```{r}
#| paged.print: False
flights |>  
    filter(arr_delay >= 15 & arr_delay < 30) |>
   group_by(origin) |> 
    count()

```

I porsent

```{r}
#| paged.print: False
 delays <- flights |>  
    filter(arr_delay >= 15 & arr_delay < 30) |>
   group_by(origin) |> 
    count() |> 
    pull()
 
 flights_orig <- flights|> 
   group_by(origin) |> 
   summarise(antall = n ()) |> 
   pull()
 
 round(100 * delays/flights_orig, 2)
```

## UKE 40

Hvis det finnes en NA (Missing Value), vil hele resultatet være NA.

-   Det går ant å sjekke om dette:

-   is.na()

sum(is.na(flights\$arr_delay))

Hvis du får opp et svar som her blir 9430, vil det betyr at det er 9430 objekter her og de har alle verdien NA.

arrange() endrer på rekkefølgen i dataen.

```{r}
names(flights)
```

```{r}
flights |> 
  arrange(month, day, sched_dep_time) |> 
print(n = 10, width = 70)
```

Her har eg sortert utifra de ulike variablene, mens onda har eg gjort det gjennmo utifra månede med bruk av desc().

```{r}
flights |> 
  arrange(desc(month), desc(day), month, day, sched_dep_time) |> 
print(n = 10, width = 70)
```

```{r}
flights |> 
  arrange(desc(month), desc(day), month, day, sched_dep_time) |> 
  select(year, day, sched_dep_time, dep_time, everything()) |> 
print(n = 10, width = 70)
```

Everything tar alle variabelen utenom det som er blitt nevnt inn i tabellen.

select() plukker variabler

```{r}
(my_vars <- select(flights, day, month, year, arr_delay))
```

Det går og ant å slette navn på variabler direkte i funkjsonen:

-   Det er mulig å gjør det videre i en pipe og rename() funksjon

```{r}
(my_vars <- select(flights, day, month, year, arr_delay) |> 
  rename(arival_delay = arr_delay))
```

Det går og ant å gjør det direkte inn i select()

```{r}
# Use a pipe
my_vars_May <- flights %>%
  filter(month == 5) %>%
  select(day, month, year, arr_delay)

median(my_vars$arival_delay)
```

```{r}
median(my_vars$arival_delay, na.rm = TRUE)
```

Hvor mange NA er det?

```{r}
sum(is.na(my_vars$arival_delay))
```

```{r}
table(is.na(my_vars$arival_delay))
```

Summarise()

Svar som vektor med et element:

Det som står onda her er feil

```{r}
names(my_vars)
```

```{r}
(my_vars <- my_vars |> 
  filter(month == 5) |> 
  select(day, month, year, arival_delay) |>
  summarise(median_arival_delay = median(arival_delay, na.rm = TRUE)) |> 
  pull()
  )
```

```{r}
my_vars
```

Mutate prøver å regne 2 nye variabler i den eksisterende.

```{r}
my_new_data <- flights %>%
  select(year:day, ends_with("delay"), distance, air_time) %>%
  mutate(
    gain = dep_delay - arr_delay,
    speed = (distance/air_time) * 60
    ) %>%
  select(year:day, gain, everything()) %>%
  arrange(gain)
head(my_new_data, n = 5) 
```
